import pytest
from tests.conftest import test_database_name, test_host, test_port
from pymongo import MongoClient
from mongoengine import connect
from mongoengine.connection import disconnect
from sibyl.db import schema
import pandas as pd
from sibyl.db import preprocessing

# Generated by CodiumAI


@pytest.fixture(autouse=True)
def empty_database():
    client = MongoClient(test_host, test_port)
    client.drop_database(test_database_name)
    connect(test_database_name, host=test_host, port=test_port)

    yield client

    client.drop_database(test_database_name)
    disconnect()


class TestInsertFeaturesFromDataframe:
    #  Insert features with required columns only
    def test_insert_required_columns_only(self):
        # Create a dataframe with only the required columns
        features_df = pd.DataFrame(
            {
                "name": ["feature1", "feature2", "feature3"],
                "type": ["numeric", "categorical", "boolean"],
            }
        )

        # Call the function under test
        result = preprocessing.insert_features_from_dataframe(features_df)

        # Assert that the result is a list of the inserted feature names
        assert result == ["feature1", "feature2", "feature3"]

        # Assert that the features were inserted into the database correctly
        inserted_features = schema.Feature.find(as_df_=True)
        assert len(inserted_features) == 3
        assert set(inserted_features["name"]) == {"feature1", "feature2", "feature3"}
        assert set(inserted_features["type"]) == {"numeric", "categorical", "boolean"}

    #  Insert features with optional columns
    def test_insert_optional_columns(self):
        # Create a dataframe with required and optional columns
        features_df = pd.DataFrame(
            {
                "name": ["feature1", "feature2", "feature3"],
                "type": ["numeric", "categorical", "boolean"],
                "description": ["Description 1", "Description 2", "Description 3"],
                "negated_description": [
                    "Negated Description 1",
                    "Negated Description 2",
                    "Negated Description 3",
                ],
                "category": ["Category 1", "Category 2", "Category 3"],
            }
        )

        # Call the function under test
        result = preprocessing.insert_features_from_dataframe(features_df)

        # Assert that the result is a list of the inserted feature names
        assert result == ["feature1", "feature2", "feature3"]

        # Assert that the features were inserted into the database correctly
        inserted_features = schema.Feature.find(as_df_=True)
        assert len(inserted_features) == 3
        assert set(inserted_features["name"]) == {"feature1", "feature2", "feature3"}
        assert set(inserted_features["type"]) == {"numeric", "categorical", "boolean"}
        assert set(inserted_features["description"]) == {
            "Description 1",
            "Description 2",
            "Description 3",
        }
        assert set(inserted_features["negated_description"]) == {
            "Negated Description 1",
            "Negated Description 2",
            "Negated Description 3",
        }
        assert set(inserted_features["category"]) == {"Category 1", "Category 2", "Category 3"}

    #  Insert features with both required and optional columns
    def test_insert_required_and_optional_columns(self):
        # Create a dataframe with required and optional columns
        features_df = pd.DataFrame(
            {
                "name": ["feature1", "feature2", "feature3"],
                "type": ["numeric", "categorical", "boolean"],
                "description": ["Description 1", "Description 2", "Description 3"],
                "negated_description": [
                    "Negated Description 1",
                    "Negated Description 2",
                    "Negated Description 3",
                ],
                "category": ["Category 1", "Category 2", "Category 3"],
            }
        )

        # Call the function under test
        result = preprocessing.insert_features_from_dataframe(features_df)

        # Assert that the result is a list of the inserted feature names
        assert result == ["feature1", "feature2", "feature3"]

        # Assert that the features were inserted into the database correctly
        inserted_features = schema.Feature.find(as_df_=True)
        assert len(inserted_features) == 3
        assert set(inserted_features["name"]) == {"feature1", "feature2", "feature3"}
        assert set(inserted_features["type"]) == {"numeric", "categorical", "boolean"}
        assert set(inserted_features["description"]) == {
            "Description 1",
            "Description 2",
            "Description 3",
        }
        assert set(inserted_features["negated_description"]) == {
            "Negated Description 1",
            "Negated Description 2",
            "Negated Description 3",
        }
        assert set(inserted_features["category"]) == {"Category 1", "Category 2", "Category 3"}

    #  Insert empty dataframe
    def test_insert_empty_dataframe(self):
        # Create an empty dataframe
        features_df = pd.DataFrame(columns=["name", "type"])

        # Call the function under test
        result = preprocessing.insert_features_from_dataframe(features_df)

        # Assert that the result is an empty list
        assert result == []

        # Assert that no features were inserted into the database
        inserted_features = schema.Feature.find(as_df_=True)
        assert len(inserted_features) == 0

    #  Insert dataframe with missing required columns
    def test_insert_missing_required_columns(self):
        # Create a dataframe with missing required columns
        features_df = pd.DataFrame({"name": ["feature1", "feature2", "feature3"]})

        # Call the function under test and expect a ValueError to be raised
        with pytest.raises(ValueError):
            preprocessing.insert_features_from_dataframe(features_df)

        # Assert that no features were inserted into the database
        inserted_features = schema.Feature.find(as_df_=True)
        assert len(inserted_features) == 0

    #  Insert dataframe with invalid type
    def test_insert_invalid_type(self):
        # Create a dataframe with an invalid type
        features_df = pd.DataFrame(
            {
                "name": ["feature1", "feature2", "feature3"],
                "type": ["numeric", "categorical", "invalid"],
            }
        )

        # Call the function under test and expect a ValueError to be raised
        with pytest.raises(ValueError):
            preprocessing.insert_features_from_dataframe(features_df)

        # Assert that no features were inserted into the database
        inserted_features = schema.Feature.find(as_df_=True)
        assert len(inserted_features) == 0
