import pytest
from tests.conftest import test_database_name, test_host, test_port
from pymongo import MongoClient
from mongoengine import connect
from mongoengine.connection import disconnect
from sibyl.db import schema
import pandas as pd
from sibyl.db import preprocessing

# Generated by CodiumAI


@pytest.fixture(autouse=True)
def empty_database():
    client = MongoClient(test_host, test_port)
    client.drop_database(test_database_name)
    connect(test_database_name, host=test_host, port=test_port)

    yield client

    client.drop_database(test_database_name)
    disconnect()


class TestInsertFeaturesFromDataframe:
    #  Insert features with required columns only
    def test_insert_required_columns_only(self):
        # Create a dataframe with only the required columns
        features_df = pd.DataFrame(
            {
                "name": ["feature1", "feature2", "feature3"],
                "type": ["numeric", "categorical", "boolean"],
            }
        )

        # Call the function under test
        result = preprocessing.insert_features_from_dataframe(features_df)

        # Assert that the result is a list of the inserted feature names
        assert result == ["feature1", "feature2", "feature3"]

        # Assert that the features were inserted into the database correctly
        inserted_features = schema.Feature.find(as_df_=True)
        assert len(inserted_features) == 3
        assert set(inserted_features["name"]) == {"feature1", "feature2", "feature3"}
        assert set(inserted_features["type"]) == {"numeric", "categorical", "boolean"}

    #  Insert features with optional columns
    def test_insert_optional_columns(self):
        # Create a dataframe with required and optional columns
        features_df = pd.DataFrame(
            {
                "name": ["feature1", "feature2", "feature3"],
                "type": ["numeric", "categorical", "boolean"],
                "description": ["Description 1", "Description 2", "Description 3"],
                "negated_description": [
                    "Negated Description 1",
                    "Negated Description 2",
                    "Negated Description 3",
                ],
                "category": ["Category 1", "Category 2", "Category 3"],
            }
        )

        # Call the function under test
        result = preprocessing.insert_features_from_dataframe(features_df)

        # Assert that the result is a list of the inserted feature names
        assert result == ["feature1", "feature2", "feature3"]

        # Assert that the features were inserted into the database correctly
        inserted_features = schema.Feature.find(as_df_=True)
        assert len(inserted_features) == 3
        assert set(inserted_features["name"]) == {"feature1", "feature2", "feature3"}
        assert set(inserted_features["type"]) == {"numeric", "categorical", "boolean"}
        assert set(inserted_features["description"]) == {
            "Description 1",
            "Description 2",
            "Description 3",
        }
        assert set(inserted_features["negated_description"]) == {
            "Negated Description 1",
            "Negated Description 2",
            "Negated Description 3",
        }
        assert set(inserted_features["category"]) == {"Category 1", "Category 2", "Category 3"}

    #  Insert features with both required and optional columns
    def test_insert_required_and_optional_columns(self):
        # Create a dataframe with required and optional columns
        features_df = pd.DataFrame(
            {
                "name": ["feature1", "feature2", "feature3"],
                "type": ["numeric", "categorical", "boolean"],
                "description": ["Description 1", "Description 2", "Description 3"],
                "negated_description": [
                    "Negated Description 1",
                    "Negated Description 2",
                    "Negated Description 3",
                ],
                "category": ["Category 1", "Category 2", "Category 3"],
            }
        )

        # Call the function under test
        result = preprocessing.insert_features_from_dataframe(features_df)

        # Assert that the result is a list of the inserted feature names
        assert result == ["feature1", "feature2", "feature3"]

        # Assert that the features were inserted into the database correctly
        inserted_features = schema.Feature.find(as_df_=True)
        assert len(inserted_features) == 3
        assert set(inserted_features["name"]) == {"feature1", "feature2", "feature3"}
        assert set(inserted_features["type"]) == {"numeric", "categorical", "boolean"}
        assert set(inserted_features["description"]) == {
            "Description 1",
            "Description 2",
            "Description 3",
        }
        assert set(inserted_features["negated_description"]) == {
            "Negated Description 1",
            "Negated Description 2",
            "Negated Description 3",
        }
        assert set(inserted_features["category"]) == {"Category 1", "Category 2", "Category 3"}

    #  Insert empty dataframe
    def test_insert_empty_dataframe(self):
        # Create an empty dataframe
        features_df = pd.DataFrame(columns=["name", "type"])

        # Call the function under test
        result = preprocessing.insert_features_from_dataframe(features_df)

        # Assert that the result is an empty list
        assert result == []

        # Assert that no features were inserted into the database
        inserted_features = schema.Feature.find(as_df_=True)
        assert len(inserted_features) == 0

    #  Insert dataframe with missing required columns
    def test_insert_missing_required_columns(self):
        # Create a dataframe with missing required columns
        features_df = pd.DataFrame({"name": ["feature1", "feature2", "feature3"]})

        # Call the function under test and expect a ValueError to be raised
        with pytest.raises(ValueError):
            preprocessing.insert_features_from_dataframe(features_df)

        # Assert that no features were inserted into the database
        inserted_features = schema.Feature.find(as_df_=True)
        assert len(inserted_features) == 0

    #  Insert dataframe with invalid type
    def test_insert_invalid_type(self):
        # Create a dataframe with an invalid type
        features_df = pd.DataFrame(
            {
                "name": ["feature1", "feature2", "feature3"],
                "type": ["numeric", "categorical", "invalid"],
            }
        )

        # Call the function under test and expect a ValueError to be raised
        with pytest.raises(ValueError):
            preprocessing.insert_features_from_dataframe(features_df)

        # Assert that no features were inserted into the database
        inserted_features = schema.Feature.find(as_df_=True)
        assert len(inserted_features) == 0


class TestInsertCategoriesFromDataframe:
    #  Insert categories with required columns only
    def test_insert_categories_required_columns_only(self):
        # Create a sample dataframe with required columns only
        category_df = pd.DataFrame({"name": ["Category1", "Category2", "Category3"]})

        # Call the function under test
        result = preprocessing.insert_categories_from_dataframe(category_df)

        # Assert that the categories were inserted correctly
        assert result == ["Category1", "Category2", "Category3"]

        inserted_categories = schema.Category.find(as_df_=True)
        assert len(inserted_categories) == 3
        assert set(inserted_categories["name"]) == {"Category1", "Category2", "Category3"}

    #  Insert categories with optional columns
    def test_insert_categories_optional_columns(self):
        # Create a sample dataframe with optional columns
        category_df = pd.DataFrame(
            {
                "name": ["Category1", "Category2", "Category3"],
                "color": ["red", "blue", "green"],
                "abbreviation": ["C1", "C2", "C3"],
            }
        )

        # Call the function under test
        result = preprocessing.insert_categories_from_dataframe(category_df)

        # Assert that the categories were inserted correctly
        assert result == ["Category1", "Category2", "Category3"]
        inserted_categories = schema.Category.find(as_df_=True)
        assert len(inserted_categories) == 3
        assert set(inserted_categories["name"]) == {"Category1", "Category2", "Category3"}
        assert set(inserted_categories["color"]) == {"red", "blue", "green"}
        assert set(inserted_categories["abbreviation"]) == {"C1", "C2", "C3"}

    #  Insert empty dataframe
    def test_insert_empty_dataframe(self):
        # Create an empty dataframe
        category_df = pd.DataFrame(columns=["name", "color", "abbreviation"])

        # Call the function under test
        result = preprocessing.insert_categories_from_dataframe(category_df)

        # Assert that no categories were inserted
        assert result == []
        inserted_categories = schema.Category.find(as_df_=True)
        assert (len(inserted_categories)) == 0

    #  Insert dataframe with missing required columns
    def test_insert_missing_required_columns(self):
        # Create a sample dataframe with missing required columns
        category_df = pd.DataFrame({"color": ["red", "blue", "green"]})

        # Call the function under test and expect a ValueError
        with pytest.raises(ValueError):
            preprocessing.insert_categories_from_dataframe(category_df)


class TestInsertContextFromDict:
    #  Insert a valid context dictionary and verify that it is inserted into the database.
    def test_valid_context_dictionary_inserted(self):
        # Arrange
        context_dict = {"context_config_key": "context_config_value"}

        # Act
        preprocessing.insert_context_from_dict(context_dict)

        # Assert
        context = schema.Context.find()[0].to_mongo()
        assert context["config"]["context_config_key"] == "context_config_value"
